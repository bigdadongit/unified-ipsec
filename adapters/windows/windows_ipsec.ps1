# Windows IPsec Adapter
# Configures Windows IPsec using PowerShell cmdlets
# Auto-generated by Unified IPsec Policy Engine

param(
    [string]$PolicyFile = "policy_temp.json"
)

# Setup logging
$LogFile = Join-Path $PSScriptRoot "..\..\logs\windows_ipsec.log"
$LogDir = Split-Path $LogFile -Parent
if (-not (Test-Path $LogDir)) {
    New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
}

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogMessage = "$Timestamp [$Level] $Message"
    Write-Host $LogMessage
    Add-Content -Path $LogFile -Value $LogMessage
}

Write-Log "========================================"
Write-Log "Windows IPsec Adapter Starting"
Write-Log "========================================"

# Check if running as Administrator
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $IsAdmin) {
    Write-Log "WARNING: Not running as Administrator. Some operations may fail." "WARN"
}

# Load policy configuration
Write-Log "Loading policy from: $PolicyFile"
if (-not (Test-Path $PolicyFile)) {
    Write-Log "Policy file not found: $PolicyFile" "ERROR"
    exit 1
}

try {
    $Policy = Get-Content $PolicyFile -Raw | ConvertFrom-Json
} catch {
    Write-Log "Failed to parse policy file: $_" "ERROR"
    exit 1
}

$Global = $Policy.global
$Tunnels = $Policy.tunnels

Write-Log "Policy loaded. Processing $($Tunnels.Count) tunnel(s)"

# Map encryption algorithms
$EncryptionMap = @{
    "aes128" = "AES128"
    "aes192" = "AES192"
    "aes256" = "AES256"
    "3des" = "3DES"
}

$IntegrityMap = @{
    "sha1" = "SHA1"
    "sha256" = "SHA256"
    "sha384" = "SHA384"
    "sha512" = "SHA512"
    "md5" = "MD5"
}

$DHGroupMap = @{
    2 = "Group2"
    5 = "Group5"
    14 = "Group14"
    15 = "Group15"
    16 = "Group16"
    17 = "Group17"
    18 = "Group18"
    19 = "Group19"
    20 = "Group20"
    21 = "Group21"
}

# Get crypto settings
$Encryption = $EncryptionMap[$Global.encryption]
$Integrity = $IntegrityMap[$Global.integrity]
$DHGroup = $DHGroupMap[[int]$Global.dh_group]
$PSK = $Global.psk

Write-Log "Encryption: $Encryption, Integrity: $Integrity, DH Group: $DHGroup"

# Configure each tunnel
foreach ($Tunnel in $Tunnels) {
    $TunnelName = $Tunnel.name
    $Mode = $Tunnel.mode
    $Protocol = $Tunnel.protocol
    $PeerIP = $Tunnel.peer_ip
    
    Write-Log "Configuring tunnel: $TunnelName (Mode: $Mode, Protocol: $Protocol, Peer: $PeerIP)"
    
    try {
        # Remove existing rule if it exists
        $ExistingRule = Get-NetIPsecRule -DisplayName $TunnelName -ErrorAction SilentlyContinue
        if ($ExistingRule) {
            Write-Log "Removing existing rule: $TunnelName"
            Remove-NetIPsecRule -DisplayName $TunnelName -ErrorAction SilentlyContinue
        }
        
        # Create connection security rule
        if ($Mode -eq "tunnel") {
            # Tunnel mode
            $LocalSubnet = $Tunnel.local_subnet
            $RemoteSubnet = $Tunnel.remote_subnet
            
            Write-Log "Creating tunnel mode rule: $LocalSubnet <-> $RemoteSubnet"
            
            # Create IPsec rule for tunnel mode
            New-NetIPsecRule -DisplayName $TunnelName `
                -InboundSecurity Require `
                -OutboundSecurity Require `
                -Protocol TCP `
                -LocalAddress $LocalSubnet `
                -RemoteAddress $RemoteSubnet `
                -InterfaceType Any `
                -Enabled True `
                -ErrorAction Stop
            
            Write-Log "✓ Tunnel mode rule created: $TunnelName"
            
        } elseif ($Mode -eq "transport") {
            # Transport mode
            Write-Log "Creating transport mode rule to peer: $PeerIP"
            
            # Create IPsec rule for transport mode
            New-NetIPsecRule -DisplayName $TunnelName `
                -InboundSecurity Require `
                -OutboundSecurity Require `
                -Protocol TCP `
                -RemoteAddress $PeerIP `
                -InterfaceType Any `
                -Enabled True `
                -ErrorAction Stop
            
            Write-Log "✓ Transport mode rule created: $TunnelName"
        }
        
        # Note: Windows IKEv2 with PSK configuration typically requires additional
        # certificate or machine certificate setup. For a hackathon demo, the rules
        # are created but may need manual PSK configuration via:
        # netsh advfirewall consec add rule name="$TunnelName" ...
        
        Write-Log "NOTE: PSK authentication may require additional configuration"
        Write-Log "      Use: netsh advfirewall consec for advanced PSK setup"
        
    } catch {
        Write-Log "Failed to configure tunnel $TunnelName : $_" "ERROR"
    }
}

# Display current IPsec rules
Write-Log "Current IPsec Rules:"
try {
    $Rules = Get-NetIPsecRule | Select-Object DisplayName, Enabled, InboundSecurity, OutboundSecurity
    foreach ($Rule in $Rules) {
        Write-Log "  - $($Rule.DisplayName): Enabled=$($Rule.Enabled), In=$($Rule.InboundSecurity), Out=$($Rule.OutboundSecurity)"
    }
} catch {
    Write-Log "Could not retrieve IPsec rules: $_" "WARN"
}

# Summary
Write-Log "========================================"
Write-Log "✓ Windows IPsec Adapter Completed"
Write-Log "========================================"
Write-Log ""
Write-Log "NEXT STEPS FOR PRODUCTION:"
Write-Log "1. Configure PSK using netsh advfirewall consec"
Write-Log "2. Verify IPsec policies with: Get-NetIPsecRule"
Write-Log "3. Test connectivity to peer endpoints"
Write-Log "4. Monitor with: Get-NetIPsecMainModeSA, Get-NetIPsecQuickModeSA"

exit 0
