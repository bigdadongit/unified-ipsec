#!/usr/bin/env python3
"""
Linux strongSwan Adapter
Converts unified policy to strongSwan configuration
"""

import os
import subprocess
import shutil
from pathlib import Path
from typing import Dict, Any
import logging


class StrongSwanAdapter:
    """Adapter for Linux strongSwan IPsec"""
    
    IPSEC_CONF = '/etc/ipsec.conf'
    IPSEC_SECRETS = '/etc/ipsec.secrets'
    
    def __init__(self, config: Dict[str, Any], logger: logging.Logger = None):
        """Initialize adapter"""
        self.config = config
        self.logger = logger or logging.getLogger(__name__)
        self.global_cfg = config.get('global', {})
        self.tunnels = config.get('tunnels', [])
    
    def generate_ipsec_conf(self) -> str:
        """Generate strongSwan ipsec.conf content"""
        lines = []
        
        # Header
        lines.append("# strongSwan IPsec Configuration")
        lines.append("# Auto-generated by Unified IPsec Policy Engine")
        lines.append("")
        
        # Global config
        lines.append("config setup")
        lines.append("    charondebug=\"ike 2, knl 2, cfg 2\"")
        lines.append("    uniqueids=no")
        lines.append("")
        
        # Generate connection for each tunnel
        for tunnel in self.tunnels:
            lines.extend(self._generate_connection(tunnel))
            lines.append("")
        
        return "\n".join(lines)
    
    def _generate_connection(self, tunnel: Dict[str, Any]) -> list:
        """Generate a single connection configuration"""
        lines = []
        name = tunnel['name']
        mode = tunnel['mode']
        protocol = tunnel['protocol']
        peer_ip = tunnel['peer_ip']
        
        # Connection header
        lines.append(f"conn {name}")
        
        # Key exchange
        ike_version = self.global_cfg.get('ike_version', 'ikev2')
        lines.append(f"    keyexchange={ike_version}")
        
        # Authentication
        auth_method = self.global_cfg.get('auth_method', 'psk')
        if auth_method == 'psk':
            lines.append("    authby=psk")
            lines.append("    left=%any")
            lines.append("    leftauth=psk")
            lines.append(f"    right={peer_ip}")
            lines.append("    rightauth=psk")
        
        # Crypto proposal
        encryption = self.global_cfg.get('encryption', 'aes256')
        integrity = self.global_cfg.get('integrity', 'sha256')
        dh_group = self.global_cfg.get('dh_group', 14)
        
        # Map our names to strongSwan names
        enc_map = {
            'aes128': 'aes128', 'aes192': 'aes192', 
            'aes256': 'aes256', '3des': '3des'
        }
        int_map = {
            'sha1': 'sha1', 'sha256': 'sha256',
            'sha384': 'sha384', 'sha512': 'sha512', 'md5': 'md5'
        }
        
        enc = enc_map.get(encryption, 'aes256')
        integ = int_map.get(integrity, 'sha256')
        
        lines.append(f"    ike={enc}-{integ}-modp{dh_group}!")
        lines.append(f"    esp={enc}-{integ}!")
        
        # Mode and protocol
        if mode == 'tunnel':
            lines.append("    type=tunnel")
            local_subnet = tunnel.get('local_subnet', '0.0.0.0/0')
            remote_subnet = tunnel.get('remote_subnet', '0.0.0.0/0')
            lines.append(f"    leftsubnet={local_subnet}")
            lines.append(f"    rightsubnet={remote_subnet}")
        elif mode == 'transport':
            lines.append("    type=transport")
        
        # Auto-start
        if self.global_cfg.get('auto_start', True):
            lines.append("    auto=start")
        else:
            lines.append("    auto=add")
        
        return lines
    
    def generate_ipsec_secrets(self) -> str:
        """Generate strongSwan ipsec.secrets content"""
        lines = []
        
        lines.append("# strongSwan IPsec Secrets")
        lines.append("# Auto-generated by Unified IPsec Policy Engine")
        lines.append("")
        
        # PSK for all connections
        auth_method = self.global_cfg.get('auth_method', 'psk')
        if auth_method == 'psk':
            psk = self.global_cfg.get('psk', '')
            lines.append(f": PSK \"{psk}\"")
        
        lines.append("")
        return "\n".join(lines)
    
    def backup_existing_config(self):
        """Backup existing strongSwan configuration"""
        for conf_file in [self.IPSEC_CONF, self.IPSEC_SECRETS]:
            if Path(conf_file).exists():
                backup = f"{conf_file}.backup"
                self.logger.info(f"Backing up {conf_file} to {backup}")
                try:
                    shutil.copy2(conf_file, backup)
                except Exception as e:
                    self.logger.warning(f"Could not backup {conf_file}: {e}")
    
    def write_config_files(self):
        """Write configuration files to /etc"""
        # Generate configs
        ipsec_conf_content = self.generate_ipsec_conf()
        ipsec_secrets_content = self.generate_ipsec_secrets()
        
        # Check if we have write permissions
        if os.geteuid() != 0:
            self.logger.warning("Not running as root. Writing to /tmp for preview.")
            conf_path = '/tmp/ipsec.conf'
            secrets_path = '/tmp/ipsec.secrets'
        else:
            conf_path = self.IPSEC_CONF
            secrets_path = self.IPSEC_SECRETS
            self.backup_existing_config()
        
        # Write ipsec.conf
        self.logger.info(f"Writing ipsec.conf to {conf_path}")
        with open(conf_path, 'w') as f:
            f.write(ipsec_conf_content)
        
        # Write ipsec.secrets
        self.logger.info(f"Writing ipsec.secrets to {secrets_path}")
        with open(secrets_path, 'w') as f:
            f.write(ipsec_secrets_content)
        
        # Set proper permissions on secrets file
        if os.geteuid() == 0:
            os.chmod(secrets_path, 0o600)
        
        self.logger.info("Configuration files written successfully")
    
    def restart_strongswan(self):
        """Restart strongSwan service"""
        if os.geteuid() != 0:
            self.logger.warning("Not running as root. Skipping service restart.")
            self.logger.info("Run: sudo systemctl restart strongswan-starter")
            return
        
        self.logger.info("Restarting strongSwan service...")
        
        try:
            # Try systemctl first
            subprocess.run(
                ['systemctl', 'restart', 'strongswan-starter'],
                check=True,
                capture_output=True,
                text=True
            )
            self.logger.info("✓ strongSwan service restarted via systemctl")
        except subprocess.CalledProcessError:
            try:
                # Fallback to ipsec command
                subprocess.run(
                    ['ipsec', 'restart'],
                    check=True,
                    capture_output=True,
                    text=True
                )
                self.logger.info("✓ strongSwan restarted via ipsec command")
            except subprocess.CalledProcessError as e:
                self.logger.error(f"Failed to restart strongSwan: {e}")
                raise
    
    def verify_status(self):
        """Verify IPsec tunnel status"""
        self.logger.info("Verifying IPsec tunnel status...")
        
        try:
            result = subprocess.run(
                ['ipsec', 'status'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            self.logger.info("IPsec Status:")
            self.logger.info(result.stdout)
            
            # Check if tunnels are established
            for tunnel in self.tunnels:
                name = tunnel['name']
                if name in result.stdout:
                    self.logger.info(f"✓ Tunnel '{name}' is configured")
                else:
                    self.logger.warning(f"⚠ Tunnel '{name}' not found in status")
                    
        except FileNotFoundError:
            self.logger.warning("ipsec command not found. Is strongSwan installed?")
        except subprocess.TimeoutExpired:
            self.logger.warning("ipsec status command timed out")
        except Exception as e:
            self.logger.warning(f"Could not verify status: {e}")
    
    def configure(self):
        """Main configuration workflow"""
        try:
            self.logger.info("Starting Linux strongSwan configuration...")
            
            # Write configuration files
            self.write_config_files()
            
            # Restart service
            self.restart_strongswan()
            
            # Verify status
            self.verify_status()
            
            self.logger.info("✓ Linux strongSwan configuration completed")
            
        except Exception as e:
            self.logger.error(f"✗ Linux strongSwan configuration failed: {e}")
            raise


def main():
    """Test adapter directly"""
    import yaml
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    # Load sample policy
    policy_path = Path(__file__).parent.parent.parent / 'controller' / 'policy.yaml'
    with open(policy_path) as f:
        config = yaml.safe_load(f)
    
    # Run adapter
    adapter = StrongSwanAdapter(config, logger)
    adapter.configure()


if __name__ == '__main__':
    main()
